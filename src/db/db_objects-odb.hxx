// This file was generated by ODB, object-relational mapping (ORM)
// compiler for C++.
//

#ifndef DB_OBJECTS_ODB_HXX
#define DB_OBJECTS_ODB_HXX

#include <odb/version.hxx>

#if (ODB_VERSION != 20400UL)
#error ODB runtime version mismatch
#endif

#include <odb/pre.hxx>

#include "db_objects.hpp"

#include <memory>
#include <cstddef>
#include <utility>

#include <odb/core.hxx>
#include <odb/traits.hxx>
#include <odb/callback.hxx>
#include <odb/wrapper-traits.hxx>
#include <odb/pointer-traits.hxx>
#include <odb/container-traits.hxx>
#include <odb/session.hxx>
#include <odb/cache-traits.hxx>
#include <odb/query-dynamic.hxx>
#include <odb/result.hxx>
#include <odb/simple-object-result.hxx>
#include <odb/view-image.hxx>
#include <odb/view-result.hxx>

#include <odb/details/unused.hxx>
#include <odb/details/shared-ptr.hxx>

namespace odb
{
  // DBConfigKV
  //
  template <>
  struct class_traits< ::DBConfigKV >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::DBConfigKV >
  {
    public:
    typedef ::DBConfigKV object_type;
    typedef ::std::shared_ptr< ::DBConfigKV > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;

    static const bool auto_id = true;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    struct cfg_tag;

    typedef
    odb::pointer_cache_traits<
      pointer_type,
      odb::session >
    pointer_cache_traits;

    typedef
    odb::reference_cache_traits<
      object_type,
      odb::session >
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };

  template <typename A>
  struct pointer_query_columns< ::DBConfigKV, id_common, A >
  {
    // cfg
    //
    typedef odb::query_column< long unsigned int > cfg_type_;

    static cfg_type_ cfg;

    // key
    //
    typedef odb::query_column< ::std::string > key_type_;

    static key_type_ key;

    // value
    //
    typedef odb::query_column< ::std::string > value_type_;

    static value_type_ value;

    // id
    //
    typedef odb::query_column< long unsigned int > id_type_;

    static id_type_ id;
  };

#ifdef ODB_COMMON_QUERY_COLUMNS_DEF

  template <typename A>
  typename pointer_query_columns< ::DBConfigKV, id_common, A >::cfg_type_
  pointer_query_columns< ::DBConfigKV, id_common, A >::cfg;

  template <typename A>
  typename pointer_query_columns< ::DBConfigKV, id_common, A >::key_type_
  pointer_query_columns< ::DBConfigKV, id_common, A >::key;

  template <typename A>
  typename pointer_query_columns< ::DBConfigKV, id_common, A >::value_type_
  pointer_query_columns< ::DBConfigKV, id_common, A >::value;

  template <typename A>
  typename pointer_query_columns< ::DBConfigKV, id_common, A >::id_type_
  pointer_query_columns< ::DBConfigKV, id_common, A >::id;

#endif // ODB_COMMON_QUERY_COLUMNS_DEF

  template <>
  class access::object_traits_impl< ::DBConfigKV, id_common >:
    public access::object_traits< ::DBConfigKV >
  {
    public:
    typedef odb::query_base query_base_type;

    struct function_table_type
    {
      void (*persist) (database&, object_type&);
      pointer_type (*find1) (database&, const id_type&);
      bool (*find2) (database&, const id_type&, object_type&);
      bool (*reload) (database&, object_type&);
      void (*update) (database&, const object_type&);
      void (*erase1) (database&, const id_type&);
      void (*erase2) (database&, const object_type&);
      result<object_type> (*query) (database&, const query_base_type&);
      unsigned long long (*erase_query) (database&, const query_base_type&);
    };

    static const function_table_type* function_table[database_count];

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);
  };

  // DBConfig
  //
  template <>
  struct class_traits< ::DBConfig >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::DBConfig >
  {
    public:
    typedef ::DBConfig object_type;
    typedef ::std::shared_ptr< ::DBConfig > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;

    static const bool auto_id = true;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    typedef
    odb::pointer_cache_traits<
      pointer_type,
      odb::session >
    pointer_cache_traits;

    typedef
    odb::reference_cache_traits<
      object_type,
      odb::session >
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };

  template <typename A>
  struct query_columns< ::DBConfig, id_common, A >
  {
    // name
    //
    typedef odb::query_column< ::std::string > name_type_;

    static name_type_ name;

    // time_limit
    //
    typedef odb::query_column< unsigned int > time_limit_type_;

    static time_limit_type_ time_limit;

    // id
    //
    typedef odb::query_column< long unsigned int > id_type_;

    static id_type_ id;
  };

#ifdef ODB_COMMON_QUERY_COLUMNS_DEF

  template <typename A>
  typename query_columns< ::DBConfig, id_common, A >::name_type_
  query_columns< ::DBConfig, id_common, A >::name;

  template <typename A>
  typename query_columns< ::DBConfig, id_common, A >::time_limit_type_
  query_columns< ::DBConfig, id_common, A >::time_limit;

  template <typename A>
  typename query_columns< ::DBConfig, id_common, A >::id_type_
  query_columns< ::DBConfig, id_common, A >::id;

#endif // ODB_COMMON_QUERY_COLUMNS_DEF

  template <typename A>
  struct pointer_query_columns< ::DBConfig, id_common, A >:
    query_columns< ::DBConfig, id_common, A >
  {
  };

  template <>
  class access::object_traits_impl< ::DBConfig, id_common >:
    public access::object_traits< ::DBConfig >
  {
    public:
    typedef odb::query_base query_base_type;

    struct function_table_type
    {
      void (*persist) (database&, object_type&);
      pointer_type (*find1) (database&, const id_type&);
      bool (*find2) (database&, const id_type&, object_type&);
      bool (*reload) (database&, object_type&);
      void (*update) (database&, const object_type&);
      void (*erase1) (database&, const id_type&);
      void (*erase2) (database&, const object_type&);
      result<object_type> (*query) (database&, const query_base_type&);
      unsigned long long (*erase_query) (database&, const query_base_type&);
    };

    static const function_table_type* function_table[database_count];

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);
  };

  // DBInvocation
  //
  template <>
  struct class_traits< ::DBInvocation >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::DBInvocation >
  {
    public:
    typedef ::DBInvocation object_type;
    typedef ::std::shared_ptr< ::DBInvocation > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;

    static const bool auto_id = true;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    typedef
    odb::pointer_cache_traits<
      pointer_type,
      odb::session >
    pointer_cache_traits;

    typedef
    odb::reference_cache_traits<
      object_type,
      odb::session >
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };

  template <typename A>
  struct query_columns< ::DBInvocation, id_common, A >
  {
    // cmdline
    //
    typedef odb::query_column< ::std::string > cmdline_type_;

    static cmdline_type_ cmdline;

    // git_revision
    //
    typedef odb::query_column< ::std::string > git_revision_type_;

    static git_revision_type_ git_revision;

    // hostname
    //
    typedef odb::query_column< ::std::string > hostname_type_;

    static hostname_type_ hostname;

    // time
    //
    typedef odb::query_column< long unsigned int > time_type_;

    static time_type_ time;

    // id
    //
    typedef odb::query_column< long unsigned int > id_type_;

    static id_type_ id;
  };

#ifdef ODB_COMMON_QUERY_COLUMNS_DEF

  template <typename A>
  typename query_columns< ::DBInvocation, id_common, A >::cmdline_type_
  query_columns< ::DBInvocation, id_common, A >::cmdline;

  template <typename A>
  typename query_columns< ::DBInvocation, id_common, A >::git_revision_type_
  query_columns< ::DBInvocation, id_common, A >::git_revision;

  template <typename A>
  typename query_columns< ::DBInvocation, id_common, A >::hostname_type_
  query_columns< ::DBInvocation, id_common, A >::hostname;

  template <typename A>
  typename query_columns< ::DBInvocation, id_common, A >::time_type_
  query_columns< ::DBInvocation, id_common, A >::time;

  template <typename A>
  typename query_columns< ::DBInvocation, id_common, A >::id_type_
  query_columns< ::DBInvocation, id_common, A >::id;

#endif // ODB_COMMON_QUERY_COLUMNS_DEF

  template <typename A>
  struct pointer_query_columns< ::DBInvocation, id_common, A >:
    query_columns< ::DBInvocation, id_common, A >
  {
  };

  template <>
  class access::object_traits_impl< ::DBInvocation, id_common >:
    public access::object_traits< ::DBInvocation >
  {
    public:
    typedef odb::query_base query_base_type;

    struct function_table_type
    {
      void (*persist) (database&, object_type&);
      pointer_type (*find1) (database&, const id_type&);
      bool (*find2) (database&, const id_type&, object_type&);
      bool (*reload) (database&, object_type&);
      void (*update) (database&, const object_type&);
      void (*erase1) (database&, const id_type&);
      void (*erase2) (database&, const object_type&);
      result<object_type> (*query) (database&, const query_base_type&);
      unsigned long long (*erase_query) (database&, const query_base_type&);
    };

    static const function_table_type* function_table[database_count];

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);
  };

  // DBResult
  //
  template <>
  struct class_traits< ::DBResult >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::DBResult >
  {
    public:
    typedef ::DBResult object_type;
    typedef ::std::shared_ptr< ::DBResult > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;

    static const bool auto_id = true;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    struct invocation_tag;
    struct cfg_tag;

    typedef
    odb::pointer_cache_traits<
      pointer_type,
      odb::session >
    pointer_cache_traits;

    typedef
    odb::reference_cache_traits<
      object_type,
      odb::session >
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };

  template <typename A>
  struct pointer_query_columns< ::DBResult, id_common, A >
  {
    // run
    //
    typedef odb::query_column< ::std::string > run_type_;

    static run_type_ run;

    // instance
    //
    typedef odb::query_column< ::std::string > instance_type_;

    static instance_type_ instance;

    // score
    //
    typedef odb::query_column< double > score_type_;

    static score_type_ score;

    // algorithm
    //
    typedef odb::query_column< ::std::string > algorithm_type_;

    static algorithm_type_ algorithm;

    // config
    //
    typedef odb::query_column< ::std::string > config_type_;

    static config_type_ config;

    // seed
    //
    typedef odb::query_column< int > seed_type_;

    static seed_type_ seed;

    // optimal
    //
    typedef odb::query_column< bool > optimal_type_;

    static optimal_type_ optimal;

    // feasible
    //
    typedef odb::query_column< bool > feasible_type_;

    static feasible_type_ feasible;

    // lower_bound
    //
    typedef odb::query_column< double > lower_bound_type_;

    static lower_bound_type_ lower_bound;

    // elapsed
    //
    typedef odb::query_column< double > elapsed_type_;

    static elapsed_type_ elapsed;

    // time
    //
    typedef odb::query_column< long unsigned int > time_type_;

    static time_type_ time;

    // invocation
    //
    typedef odb::query_column< long unsigned int > invocation_type_;

    static invocation_type_ invocation;

    // cfg
    //
    typedef odb::query_column< long unsigned int > cfg_type_;

    static cfg_type_ cfg;

    // id
    //
    typedef odb::query_column< long unsigned int > id_type_;

    static id_type_ id;
  };

#ifdef ODB_COMMON_QUERY_COLUMNS_DEF

  template <typename A>
  typename pointer_query_columns< ::DBResult, id_common, A >::run_type_
  pointer_query_columns< ::DBResult, id_common, A >::run;

  template <typename A>
  typename pointer_query_columns< ::DBResult, id_common, A >::instance_type_
  pointer_query_columns< ::DBResult, id_common, A >::instance;

  template <typename A>
  typename pointer_query_columns< ::DBResult, id_common, A >::score_type_
  pointer_query_columns< ::DBResult, id_common, A >::score;

  template <typename A>
  typename pointer_query_columns< ::DBResult, id_common, A >::algorithm_type_
  pointer_query_columns< ::DBResult, id_common, A >::algorithm;

  template <typename A>
  typename pointer_query_columns< ::DBResult, id_common, A >::config_type_
  pointer_query_columns< ::DBResult, id_common, A >::config;

  template <typename A>
  typename pointer_query_columns< ::DBResult, id_common, A >::seed_type_
  pointer_query_columns< ::DBResult, id_common, A >::seed;

  template <typename A>
  typename pointer_query_columns< ::DBResult, id_common, A >::optimal_type_
  pointer_query_columns< ::DBResult, id_common, A >::optimal;

  template <typename A>
  typename pointer_query_columns< ::DBResult, id_common, A >::feasible_type_
  pointer_query_columns< ::DBResult, id_common, A >::feasible;

  template <typename A>
  typename pointer_query_columns< ::DBResult, id_common, A >::lower_bound_type_
  pointer_query_columns< ::DBResult, id_common, A >::lower_bound;

  template <typename A>
  typename pointer_query_columns< ::DBResult, id_common, A >::elapsed_type_
  pointer_query_columns< ::DBResult, id_common, A >::elapsed;

  template <typename A>
  typename pointer_query_columns< ::DBResult, id_common, A >::time_type_
  pointer_query_columns< ::DBResult, id_common, A >::time;

  template <typename A>
  typename pointer_query_columns< ::DBResult, id_common, A >::invocation_type_
  pointer_query_columns< ::DBResult, id_common, A >::invocation;

  template <typename A>
  typename pointer_query_columns< ::DBResult, id_common, A >::cfg_type_
  pointer_query_columns< ::DBResult, id_common, A >::cfg;

  template <typename A>
  typename pointer_query_columns< ::DBResult, id_common, A >::id_type_
  pointer_query_columns< ::DBResult, id_common, A >::id;

#endif // ODB_COMMON_QUERY_COLUMNS_DEF

  template <>
  class access::object_traits_impl< ::DBResult, id_common >:
    public access::object_traits< ::DBResult >
  {
    public:
    typedef odb::query_base query_base_type;

    struct function_table_type
    {
      void (*persist) (database&, object_type&);
      pointer_type (*find1) (database&, const id_type&);
      bool (*find2) (database&, const id_type&, object_type&);
      bool (*reload) (database&, object_type&);
      void (*update) (database&, const object_type&);
      void (*erase1) (database&, const id_type&);
      void (*erase2) (database&, const object_type&);
      result<object_type> (*query) (database&, const query_base_type&);
      unsigned long long (*erase_query) (database&, const query_base_type&);
    };

    static const function_table_type* function_table[database_count];

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);
  };

  // DBResourcesInfo
  //
  template <>
  struct class_traits< ::DBResourcesInfo >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::DBResourcesInfo >
  {
    public:
    typedef ::DBResourcesInfo object_type;
    typedef ::std::shared_ptr< ::DBResourcesInfo > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;

    static const bool auto_id = true;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    struct res_tag;

    typedef
    odb::pointer_cache_traits<
      pointer_type,
      odb::session >
    pointer_cache_traits;

    typedef
    odb::reference_cache_traits<
      object_type,
      odb::session >
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };

  template <typename A>
  struct pointer_query_columns< ::DBResourcesInfo, id_common, A >
  {
    // res
    //
    typedef odb::query_column< long unsigned int > res_type_;

    static res_type_ res;

    // major_pagefaults
    //
    typedef odb::query_column< ::size_t > major_pagefaults_type_;

    static major_pagefaults_type_ major_pagefaults;

    // minor_pagefaults
    //
    typedef odb::query_column< ::size_t > minor_pagefaults_type_;

    static minor_pagefaults_type_ minor_pagefaults;

    // user_usecs
    //
    typedef odb::query_column< long unsigned int > user_usecs_type_;

    static user_usecs_type_ user_usecs;

    // system_usecs
    //
    typedef odb::query_column< long unsigned int > system_usecs_type_;

    static system_usecs_type_ system_usecs;

    // max_rss_size
    //
    typedef odb::query_column< long unsigned int > max_rss_size_type_;

    static max_rss_size_type_ max_rss_size;

    // max_data_size
    //
    typedef odb::query_column< long unsigned int > max_data_size_type_;

    static max_data_size_type_ max_data_size;

    // malloc_max_size
    //
    typedef odb::query_column< long unsigned int > malloc_max_size_type_;

    static malloc_max_size_type_ malloc_max_size;

    // malloc_count
    //
    typedef odb::query_column< long unsigned int > malloc_count_type_;

    static malloc_count_type_ malloc_count;

    // id
    //
    typedef odb::query_column< long unsigned int > id_type_;

    static id_type_ id;
  };

#ifdef ODB_COMMON_QUERY_COLUMNS_DEF

  template <typename A>
  typename pointer_query_columns< ::DBResourcesInfo, id_common, A >::res_type_
  pointer_query_columns< ::DBResourcesInfo, id_common, A >::res;

  template <typename A>
  typename pointer_query_columns< ::DBResourcesInfo, id_common, A >::major_pagefaults_type_
  pointer_query_columns< ::DBResourcesInfo, id_common, A >::major_pagefaults;

  template <typename A>
  typename pointer_query_columns< ::DBResourcesInfo, id_common, A >::minor_pagefaults_type_
  pointer_query_columns< ::DBResourcesInfo, id_common, A >::minor_pagefaults;

  template <typename A>
  typename pointer_query_columns< ::DBResourcesInfo, id_common, A >::user_usecs_type_
  pointer_query_columns< ::DBResourcesInfo, id_common, A >::user_usecs;

  template <typename A>
  typename pointer_query_columns< ::DBResourcesInfo, id_common, A >::system_usecs_type_
  pointer_query_columns< ::DBResourcesInfo, id_common, A >::system_usecs;

  template <typename A>
  typename pointer_query_columns< ::DBResourcesInfo, id_common, A >::max_rss_size_type_
  pointer_query_columns< ::DBResourcesInfo, id_common, A >::max_rss_size;

  template <typename A>
  typename pointer_query_columns< ::DBResourcesInfo, id_common, A >::max_data_size_type_
  pointer_query_columns< ::DBResourcesInfo, id_common, A >::max_data_size;

  template <typename A>
  typename pointer_query_columns< ::DBResourcesInfo, id_common, A >::malloc_max_size_type_
  pointer_query_columns< ::DBResourcesInfo, id_common, A >::malloc_max_size;

  template <typename A>
  typename pointer_query_columns< ::DBResourcesInfo, id_common, A >::malloc_count_type_
  pointer_query_columns< ::DBResourcesInfo, id_common, A >::malloc_count;

  template <typename A>
  typename pointer_query_columns< ::DBResourcesInfo, id_common, A >::id_type_
  pointer_query_columns< ::DBResourcesInfo, id_common, A >::id;

#endif // ODB_COMMON_QUERY_COLUMNS_DEF

  template <>
  class access::object_traits_impl< ::DBResourcesInfo, id_common >:
    public access::object_traits< ::DBResourcesInfo >
  {
    public:
    typedef odb::query_base query_base_type;

    struct function_table_type
    {
      void (*persist) (database&, object_type&);
      pointer_type (*find1) (database&, const id_type&);
      bool (*find2) (database&, const id_type&, object_type&);
      bool (*reload) (database&, object_type&);
      void (*update) (database&, const object_type&);
      void (*erase1) (database&, const id_type&);
      void (*erase2) (database&, const object_type&);
      result<object_type> (*query) (database&, const query_base_type&);
      unsigned long long (*erase_query) (database&, const query_base_type&);
    };

    static const function_table_type* function_table[database_count];

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);
  };

  // DBPapiMeasurement
  //
  template <>
  struct class_traits< ::DBPapiMeasurement >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::DBPapiMeasurement >
  {
    public:
    typedef ::DBPapiMeasurement object_type;
    typedef ::std::shared_ptr< ::DBPapiMeasurement > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;

    static const bool auto_id = true;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    struct res_tag;

    typedef
    odb::pointer_cache_traits<
      pointer_type,
      odb::session >
    pointer_cache_traits;

    typedef
    odb::reference_cache_traits<
      object_type,
      odb::session >
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };

  template <typename A>
  struct pointer_query_columns< ::DBPapiMeasurement, id_common, A >
  {
    // res
    //
    typedef odb::query_column< long unsigned int > res_type_;

    static res_type_ res;

    // event_type
    //
    typedef odb::query_column< ::std::string > event_type_type_;

    static event_type_type_ event_type;

    // event_count
    //
    typedef odb::query_column< long long int > event_count_type_;

    static event_count_type_ event_count;

    // id
    //
    typedef odb::query_column< long unsigned int > id_type_;

    static id_type_ id;
  };

#ifdef ODB_COMMON_QUERY_COLUMNS_DEF

  template <typename A>
  typename pointer_query_columns< ::DBPapiMeasurement, id_common, A >::res_type_
  pointer_query_columns< ::DBPapiMeasurement, id_common, A >::res;

  template <typename A>
  typename pointer_query_columns< ::DBPapiMeasurement, id_common, A >::event_type_type_
  pointer_query_columns< ::DBPapiMeasurement, id_common, A >::event_type;

  template <typename A>
  typename pointer_query_columns< ::DBPapiMeasurement, id_common, A >::event_count_type_
  pointer_query_columns< ::DBPapiMeasurement, id_common, A >::event_count;

  template <typename A>
  typename pointer_query_columns< ::DBPapiMeasurement, id_common, A >::id_type_
  pointer_query_columns< ::DBPapiMeasurement, id_common, A >::id;

#endif // ODB_COMMON_QUERY_COLUMNS_DEF

  template <>
  class access::object_traits_impl< ::DBPapiMeasurement, id_common >:
    public access::object_traits< ::DBPapiMeasurement >
  {
    public:
    typedef odb::query_base query_base_type;

    struct function_table_type
    {
      void (*persist) (database&, object_type&);
      pointer_type (*find1) (database&, const id_type&);
      bool (*find2) (database&, const id_type&, object_type&);
      bool (*reload) (database&, object_type&);
      void (*update) (database&, const object_type&);
      void (*erase1) (database&, const id_type&);
      void (*erase2) (database&, const object_type&);
      result<object_type> (*query) (database&, const query_base_type&);
      unsigned long long (*erase_query) (database&, const query_base_type&);
    };

    static const function_table_type* function_table[database_count];

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);
  };

  // DBSolution
  //
  template <>
  struct class_traits< ::DBSolution >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::DBSolution >
  {
    public:
    typedef ::DBSolution object_type;
    typedef ::std::shared_ptr< ::DBSolution > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;

    static const bool auto_id = true;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    struct res_tag;

    typedef
    odb::pointer_cache_traits<
      pointer_type,
      odb::session >
    pointer_cache_traits;

    typedef
    odb::reference_cache_traits<
      object_type,
      odb::session >
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };

  template <typename A>
  struct pointer_query_columns< ::DBSolution, id_common, A >
  {
    // res
    //
    typedef odb::query_column< long unsigned int > res_type_;

    static res_type_ res;

    // id
    //
    typedef odb::query_column< long unsigned int > id_type_;

    static id_type_ id;
  };

#ifdef ODB_COMMON_QUERY_COLUMNS_DEF

  template <typename A>
  typename pointer_query_columns< ::DBSolution, id_common, A >::res_type_
  pointer_query_columns< ::DBSolution, id_common, A >::res;

  template <typename A>
  typename pointer_query_columns< ::DBSolution, id_common, A >::id_type_
  pointer_query_columns< ::DBSolution, id_common, A >::id;

#endif // ODB_COMMON_QUERY_COLUMNS_DEF

  template <>
  class access::object_traits_impl< ::DBSolution, id_common >:
    public access::object_traits< ::DBSolution >
  {
    public:
    typedef odb::query_base query_base_type;

    struct function_table_type
    {
      void (*persist) (database&, object_type&);
      pointer_type (*find1) (database&, const id_type&);
      bool (*find2) (database&, const id_type&, object_type&);
      bool (*reload) (database&, object_type&);
      void (*update) (database&, const object_type&);
      void (*erase1) (database&, const id_type&);
      void (*erase2) (database&, const object_type&);
      result<object_type> (*query) (database&, const query_base_type&);
      unsigned long long (*erase_query) (database&, const query_base_type&);
    };

    static const function_table_type* function_table[database_count];

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);
  };

  // DBSolutionJob
  //
  template <>
  struct class_traits< ::DBSolutionJob >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::DBSolutionJob >
  {
    public:
    typedef ::DBSolutionJob object_type;
    typedef ::std::shared_ptr< ::DBSolutionJob > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;

    static const bool auto_id = true;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    struct sol_tag;

    typedef
    odb::pointer_cache_traits<
      pointer_type,
      odb::session >
    pointer_cache_traits;

    typedef
    odb::reference_cache_traits<
      object_type,
      odb::session >
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };

  template <typename A>
  struct pointer_query_columns< ::DBSolutionJob, id_common, A >
  {
    // sol
    //
    typedef odb::query_column< long unsigned int > sol_type_;

    static sol_type_ sol;

    // job_id
    //
    typedef odb::query_column< unsigned int > job_id_type_;

    static job_id_type_ job_id;

    // start_time
    //
    typedef odb::query_column< unsigned int > start_time_type_;

    static start_time_type_ start_time;

    // id
    //
    typedef odb::query_column< long unsigned int > id_type_;

    static id_type_ id;
  };

#ifdef ODB_COMMON_QUERY_COLUMNS_DEF

  template <typename A>
  typename pointer_query_columns< ::DBSolutionJob, id_common, A >::sol_type_
  pointer_query_columns< ::DBSolutionJob, id_common, A >::sol;

  template <typename A>
  typename pointer_query_columns< ::DBSolutionJob, id_common, A >::job_id_type_
  pointer_query_columns< ::DBSolutionJob, id_common, A >::job_id;

  template <typename A>
  typename pointer_query_columns< ::DBSolutionJob, id_common, A >::start_time_type_
  pointer_query_columns< ::DBSolutionJob, id_common, A >::start_time;

  template <typename A>
  typename pointer_query_columns< ::DBSolutionJob, id_common, A >::id_type_
  pointer_query_columns< ::DBSolutionJob, id_common, A >::id;

#endif // ODB_COMMON_QUERY_COLUMNS_DEF

  template <>
  class access::object_traits_impl< ::DBSolutionJob, id_common >:
    public access::object_traits< ::DBSolutionJob >
  {
    public:
    typedef odb::query_base query_base_type;

    struct function_table_type
    {
      void (*persist) (database&, object_type&);
      pointer_type (*find1) (database&, const id_type&);
      bool (*find2) (database&, const id_type&, object_type&);
      bool (*reload) (database&, object_type&);
      void (*update) (database&, const object_type&);
      void (*erase1) (database&, const id_type&);
      void (*erase2) (database&, const object_type&);
      result<object_type> (*query) (database&, const query_base_type&);
      unsigned long long (*erase_query) (database&, const query_base_type&);
    };

    static const function_table_type* function_table[database_count];

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);
  };

  // DBIntermediate
  //
  template <>
  struct class_traits< ::DBIntermediate >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::DBIntermediate >
  {
    public:
    typedef ::DBIntermediate object_type;
    typedef ::std::shared_ptr< ::DBIntermediate > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;

    static const bool auto_id = true;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    struct res_tag;
    struct solution_tag;

    typedef
    odb::pointer_cache_traits<
      pointer_type,
      odb::session >
    pointer_cache_traits;

    typedef
    odb::reference_cache_traits<
      object_type,
      odb::session >
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };

  template <typename A>
  struct pointer_query_columns< ::DBIntermediate, id_common, A >
  {
    // res
    //
    typedef odb::query_column< long unsigned int > res_type_;

    static res_type_ res;

    // time
    //
    typedef odb::query_column< double > time_type_;

    static time_type_ time;

    // iteration
    //
    typedef odb::query_column< unsigned int > iteration_type_;

    static iteration_type_ iteration;

    // costs
    //
    typedef odb::query_column< double > costs_type_;

    static costs_type_ costs;

    // bound
    //
    typedef odb::query_column< double > bound_type_;

    static bound_type_ bound;

    // solution
    //
    typedef odb::query_column< long unsigned int > solution_type_;

    static solution_type_ solution;

    // id
    //
    typedef odb::query_column< long unsigned int > id_type_;

    static id_type_ id;
  };

#ifdef ODB_COMMON_QUERY_COLUMNS_DEF

  template <typename A>
  typename pointer_query_columns< ::DBIntermediate, id_common, A >::res_type_
  pointer_query_columns< ::DBIntermediate, id_common, A >::res;

  template <typename A>
  typename pointer_query_columns< ::DBIntermediate, id_common, A >::time_type_
  pointer_query_columns< ::DBIntermediate, id_common, A >::time;

  template <typename A>
  typename pointer_query_columns< ::DBIntermediate, id_common, A >::iteration_type_
  pointer_query_columns< ::DBIntermediate, id_common, A >::iteration;

  template <typename A>
  typename pointer_query_columns< ::DBIntermediate, id_common, A >::costs_type_
  pointer_query_columns< ::DBIntermediate, id_common, A >::costs;

  template <typename A>
  typename pointer_query_columns< ::DBIntermediate, id_common, A >::bound_type_
  pointer_query_columns< ::DBIntermediate, id_common, A >::bound;

  template <typename A>
  typename pointer_query_columns< ::DBIntermediate, id_common, A >::solution_type_
  pointer_query_columns< ::DBIntermediate, id_common, A >::solution;

  template <typename A>
  typename pointer_query_columns< ::DBIntermediate, id_common, A >::id_type_
  pointer_query_columns< ::DBIntermediate, id_common, A >::id;

#endif // ODB_COMMON_QUERY_COLUMNS_DEF

  template <>
  class access::object_traits_impl< ::DBIntermediate, id_common >:
    public access::object_traits< ::DBIntermediate >
  {
    public:
    typedef odb::query_base query_base_type;

    struct function_table_type
    {
      void (*persist) (database&, object_type&);
      pointer_type (*find1) (database&, const id_type&);
      bool (*find2) (database&, const id_type&, object_type&);
      bool (*reload) (database&, object_type&);
      void (*update) (database&, const object_type&);
      void (*erase1) (database&, const id_type&);
      void (*erase2) (database&, const object_type&);
      result<object_type> (*query) (database&, const query_base_type&);
      unsigned long long (*erase_query) (database&, const query_base_type&);
    };

    static const function_table_type* function_table[database_count];

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);
  };

  // DBError
  //
  template <>
  struct class_traits< ::DBError >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::DBError >
  {
    public:
    typedef ::DBError object_type;
    typedef ::std::shared_ptr< ::DBError > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;

    static const bool auto_id = true;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    typedef
    odb::pointer_cache_traits<
      pointer_type,
      odb::session >
    pointer_cache_traits;

    typedef
    odb::reference_cache_traits<
      object_type,
      odb::session >
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };

  template <typename A>
  struct query_columns< ::DBError, id_common, A >
  {
    // timestamp
    //
    typedef odb::query_column< long unsigned int > timestamp_type_;

    static timestamp_type_ timestamp;

    // run
    //
    typedef odb::query_column< ::std::string > run_type_;

    static run_type_ run;

    // instance
    //
    typedef odb::query_column< ::std::string > instance_type_;

    static instance_type_ instance;

    // algorithm
    //
    typedef odb::query_column< ::std::string > algorithm_type_;

    static algorithm_type_ algorithm;

    // config
    //
    typedef odb::query_column< ::std::string > config_type_;

    static config_type_ config;

    // seed
    //
    typedef odb::query_column< int > seed_type_;

    static seed_type_ seed;

    // fault_code
    //
    typedef odb::query_column< int > fault_code_type_;

    static fault_code_type_ fault_code;

    // error_id
    //
    typedef odb::query_column< int > error_id_type_;

    static error_id_type_ error_id;

    // time
    //
    typedef odb::query_column< long unsigned int > time_type_;

    static time_type_ time;

    // git_revision
    //
    typedef odb::query_column< ::std::string > git_revision_type_;

    static git_revision_type_ git_revision;

    // id
    //
    typedef odb::query_column< long unsigned int > id_type_;

    static id_type_ id;
  };

#ifdef ODB_COMMON_QUERY_COLUMNS_DEF

  template <typename A>
  typename query_columns< ::DBError, id_common, A >::timestamp_type_
  query_columns< ::DBError, id_common, A >::timestamp;

  template <typename A>
  typename query_columns< ::DBError, id_common, A >::run_type_
  query_columns< ::DBError, id_common, A >::run;

  template <typename A>
  typename query_columns< ::DBError, id_common, A >::instance_type_
  query_columns< ::DBError, id_common, A >::instance;

  template <typename A>
  typename query_columns< ::DBError, id_common, A >::algorithm_type_
  query_columns< ::DBError, id_common, A >::algorithm;

  template <typename A>
  typename query_columns< ::DBError, id_common, A >::config_type_
  query_columns< ::DBError, id_common, A >::config;

  template <typename A>
  typename query_columns< ::DBError, id_common, A >::seed_type_
  query_columns< ::DBError, id_common, A >::seed;

  template <typename A>
  typename query_columns< ::DBError, id_common, A >::fault_code_type_
  query_columns< ::DBError, id_common, A >::fault_code;

  template <typename A>
  typename query_columns< ::DBError, id_common, A >::error_id_type_
  query_columns< ::DBError, id_common, A >::error_id;

  template <typename A>
  typename query_columns< ::DBError, id_common, A >::time_type_
  query_columns< ::DBError, id_common, A >::time;

  template <typename A>
  typename query_columns< ::DBError, id_common, A >::git_revision_type_
  query_columns< ::DBError, id_common, A >::git_revision;

  template <typename A>
  typename query_columns< ::DBError, id_common, A >::id_type_
  query_columns< ::DBError, id_common, A >::id;

#endif // ODB_COMMON_QUERY_COLUMNS_DEF

  template <typename A>
  struct pointer_query_columns< ::DBError, id_common, A >:
    query_columns< ::DBError, id_common, A >
  {
  };

  template <>
  class access::object_traits_impl< ::DBError, id_common >:
    public access::object_traits< ::DBError >
  {
    public:
    typedef odb::query_base query_base_type;

    struct function_table_type
    {
      void (*persist) (database&, object_type&);
      pointer_type (*find1) (database&, const id_type&);
      bool (*find2) (database&, const id_type&, object_type&);
      bool (*reload) (database&, object_type&);
      void (*update) (database&, const object_type&);
      void (*erase1) (database&, const id_type&);
      void (*erase2) (database&, const object_type&);
      result<object_type> (*query) (database&, const query_base_type&);
      unsigned long long (*erase_query) (database&, const query_base_type&);
    };

    static const function_table_type* function_table[database_count];

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);
  };

  // DBExtendedMeasure
  //
  template <>
  struct class_traits< ::DBExtendedMeasure >
  {
    static const class_kind kind = class_object;
  };

  template <>
  class access::object_traits< ::DBExtendedMeasure >
  {
    public:
    typedef ::DBExtendedMeasure object_type;
    typedef ::std::shared_ptr< ::DBExtendedMeasure > pointer_type;
    typedef odb::pointer_traits<pointer_type> pointer_traits;

    static const bool polymorphic = false;

    typedef long unsigned int id_type;

    static const bool auto_id = true;

    static const bool abstract = false;

    static id_type
    id (const object_type&);

    struct res_tag;

    typedef
    odb::pointer_cache_traits<
      pointer_type,
      odb::session >
    pointer_cache_traits;

    typedef
    odb::reference_cache_traits<
      object_type,
      odb::session >
    reference_cache_traits;

    static void
    callback (database&, object_type&, callback_event);

    static void
    callback (database&, const object_type&, callback_event);
  };

  template <typename A>
  struct pointer_query_columns< ::DBExtendedMeasure, id_common, A >
  {
    // res
    //
    typedef odb::query_column< long unsigned int > res_type_;

    static res_type_ res;

    // key
    //
    typedef odb::query_column< ::std::string > key_type_;

    static key_type_ key;

    // iteration
    //
    typedef odb::query_column< unsigned int > iteration_type_;

    static iteration_type_ iteration;

    // time
    //
    typedef odb::query_column< double > time_type_;

    static time_type_ time;

    // v_int
    //
    typedef odb::query_column< int > v_int_type_;

    static v_int_type_ v_int;

    // v_double
    //
    typedef odb::query_column< double > v_double_type_;

    static v_double_type_ v_double;

    // id
    //
    typedef odb::query_column< long unsigned int > id_type_;

    static id_type_ id;
  };

#ifdef ODB_COMMON_QUERY_COLUMNS_DEF

  template <typename A>
  typename pointer_query_columns< ::DBExtendedMeasure, id_common, A >::res_type_
  pointer_query_columns< ::DBExtendedMeasure, id_common, A >::res;

  template <typename A>
  typename pointer_query_columns< ::DBExtendedMeasure, id_common, A >::key_type_
  pointer_query_columns< ::DBExtendedMeasure, id_common, A >::key;

  template <typename A>
  typename pointer_query_columns< ::DBExtendedMeasure, id_common, A >::iteration_type_
  pointer_query_columns< ::DBExtendedMeasure, id_common, A >::iteration;

  template <typename A>
  typename pointer_query_columns< ::DBExtendedMeasure, id_common, A >::time_type_
  pointer_query_columns< ::DBExtendedMeasure, id_common, A >::time;

  template <typename A>
  typename pointer_query_columns< ::DBExtendedMeasure, id_common, A >::v_int_type_
  pointer_query_columns< ::DBExtendedMeasure, id_common, A >::v_int;

  template <typename A>
  typename pointer_query_columns< ::DBExtendedMeasure, id_common, A >::v_double_type_
  pointer_query_columns< ::DBExtendedMeasure, id_common, A >::v_double;

  template <typename A>
  typename pointer_query_columns< ::DBExtendedMeasure, id_common, A >::id_type_
  pointer_query_columns< ::DBExtendedMeasure, id_common, A >::id;

#endif // ODB_COMMON_QUERY_COLUMNS_DEF

  template <>
  class access::object_traits_impl< ::DBExtendedMeasure, id_common >:
    public access::object_traits< ::DBExtendedMeasure >
  {
    public:
    typedef odb::query_base query_base_type;

    struct function_table_type
    {
      void (*persist) (database&, object_type&);
      pointer_type (*find1) (database&, const id_type&);
      bool (*find2) (database&, const id_type&, object_type&);
      bool (*reload) (database&, object_type&);
      void (*update) (database&, const object_type&);
      void (*erase1) (database&, const id_type&);
      void (*erase2) (database&, const object_type&);
      result<object_type> (*query) (database&, const query_base_type&);
      unsigned long long (*erase_query) (database&, const query_base_type&);
    };

    static const function_table_type* function_table[database_count];

    static void
    persist (database&, object_type&);

    static pointer_type
    find (database&, const id_type&);

    static bool
    find (database&, const id_type&, object_type&);

    static bool
    reload (database&, object_type&);

    static void
    update (database&, const object_type&);

    static void
    erase (database&, const id_type&);

    static void
    erase (database&, const object_type&);

    static result<object_type>
    query (database&, const query_base_type&);

    static unsigned long long
    erase_query (database&, const query_base_type&);
  };

  // ConfigGetterView
  //
  template <>
  struct class_traits< ::ConfigGetterView >
  {
    static const class_kind kind = class_view;
  };

  template <>
  class access::view_traits< ::ConfigGetterView >
  {
    public:
    typedef ::ConfigGetterView view_type;
    typedef ::std::shared_ptr< ::ConfigGetterView > pointer_type;

    static void
    callback (database&, view_type&, callback_event);
  };

  template <>
  class access::view_traits_impl< ::ConfigGetterView, id_common >:
    public access::view_traits< ::ConfigGetterView >
  {
    public:
    typedef odb::query_base query_base_type;
    struct query_columns
    {
    };

    struct function_table_type
    {
      result<view_type> (*query) (database&, const query_base_type&);
    };

    static const function_table_type* function_table[database_count];

    static result<view_type>
    query (database&, const query_base_type&);
  };

  // DBConfigKV
  //
  template <>
  struct alias_traits<
    ::DBConfig,
    id_common,
    access::object_traits_impl< ::DBConfigKV, id_common >::cfg_tag>
  {
  };

  template <>
  struct query_columns_base< ::DBConfigKV, id_common >
  {
    // cfg
    //
    typedef
    odb::alias_traits<
      ::DBConfig,
      id_common,
      access::object_traits_impl< ::DBConfigKV, id_common >::cfg_tag>
    cfg_alias_;
  };

  template <typename A>
  struct query_columns< ::DBConfigKV, id_common, A >:
    query_columns_base< ::DBConfigKV, id_common >
  {
    // cfg
    //
    typedef odb::query_column< long unsigned int > cfg_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::DBConfig,
        id_common,
        cfg_alias_ > >
    cfg_pointer_type_;

    struct cfg_type_: cfg_pointer_type_, cfg_column_type_
    {
    };

    static cfg_type_ cfg;

    // key
    //
    typedef odb::query_column< ::std::string > key_type_;

    static key_type_ key;

    // value
    //
    typedef odb::query_column< ::std::string > value_type_;

    static value_type_ value;

    // id
    //
    typedef odb::query_column< long unsigned int > id_type_;

    static id_type_ id;
  };

#ifdef ODB_COMMON_QUERY_COLUMNS_DEF

  template <typename A>
  typename query_columns< ::DBConfigKV, id_common, A >::cfg_type_
  query_columns< ::DBConfigKV, id_common, A >::cfg;

  template <typename A>
  typename query_columns< ::DBConfigKV, id_common, A >::key_type_
  query_columns< ::DBConfigKV, id_common, A >::key;

  template <typename A>
  typename query_columns< ::DBConfigKV, id_common, A >::value_type_
  query_columns< ::DBConfigKV, id_common, A >::value;

  template <typename A>
  typename query_columns< ::DBConfigKV, id_common, A >::id_type_
  query_columns< ::DBConfigKV, id_common, A >::id;

#endif // ODB_COMMON_QUERY_COLUMNS_DEF

  // DBConfig
  //
  // DBInvocation
  //
  // DBResult
  //
  template <>
  struct alias_traits<
    ::DBInvocation,
    id_common,
    access::object_traits_impl< ::DBResult, id_common >::invocation_tag>
  {
  };

  template <>
  struct alias_traits<
    ::DBConfig,
    id_common,
    access::object_traits_impl< ::DBResult, id_common >::cfg_tag>
  {
  };

  template <>
  struct query_columns_base< ::DBResult, id_common >
  {
    // invocation
    //
    typedef
    odb::alias_traits<
      ::DBInvocation,
      id_common,
      access::object_traits_impl< ::DBResult, id_common >::invocation_tag>
    invocation_alias_;

    // cfg
    //
    typedef
    odb::alias_traits<
      ::DBConfig,
      id_common,
      access::object_traits_impl< ::DBResult, id_common >::cfg_tag>
    cfg_alias_;
  };

  template <typename A>
  struct query_columns< ::DBResult, id_common, A >:
    query_columns_base< ::DBResult, id_common >
  {
    // run
    //
    typedef odb::query_column< ::std::string > run_type_;

    static run_type_ run;

    // instance
    //
    typedef odb::query_column< ::std::string > instance_type_;

    static instance_type_ instance;

    // score
    //
    typedef odb::query_column< double > score_type_;

    static score_type_ score;

    // algorithm
    //
    typedef odb::query_column< ::std::string > algorithm_type_;

    static algorithm_type_ algorithm;

    // config
    //
    typedef odb::query_column< ::std::string > config_type_;

    static config_type_ config;

    // seed
    //
    typedef odb::query_column< int > seed_type_;

    static seed_type_ seed;

    // optimal
    //
    typedef odb::query_column< bool > optimal_type_;

    static optimal_type_ optimal;

    // feasible
    //
    typedef odb::query_column< bool > feasible_type_;

    static feasible_type_ feasible;

    // lower_bound
    //
    typedef odb::query_column< double > lower_bound_type_;

    static lower_bound_type_ lower_bound;

    // elapsed
    //
    typedef odb::query_column< double > elapsed_type_;

    static elapsed_type_ elapsed;

    // time
    //
    typedef odb::query_column< long unsigned int > time_type_;

    static time_type_ time;

    // invocation
    //
    typedef odb::query_column< long unsigned int > invocation_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::DBInvocation,
        id_common,
        invocation_alias_ > >
    invocation_pointer_type_;

    struct invocation_type_: invocation_pointer_type_, invocation_column_type_
    {
    };

    static invocation_type_ invocation;

    // cfg
    //
    typedef odb::query_column< long unsigned int > cfg_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::DBConfig,
        id_common,
        cfg_alias_ > >
    cfg_pointer_type_;

    struct cfg_type_: cfg_pointer_type_, cfg_column_type_
    {
    };

    static cfg_type_ cfg;

    // id
    //
    typedef odb::query_column< long unsigned int > id_type_;

    static id_type_ id;
  };

#ifdef ODB_COMMON_QUERY_COLUMNS_DEF

  template <typename A>
  typename query_columns< ::DBResult, id_common, A >::run_type_
  query_columns< ::DBResult, id_common, A >::run;

  template <typename A>
  typename query_columns< ::DBResult, id_common, A >::instance_type_
  query_columns< ::DBResult, id_common, A >::instance;

  template <typename A>
  typename query_columns< ::DBResult, id_common, A >::score_type_
  query_columns< ::DBResult, id_common, A >::score;

  template <typename A>
  typename query_columns< ::DBResult, id_common, A >::algorithm_type_
  query_columns< ::DBResult, id_common, A >::algorithm;

  template <typename A>
  typename query_columns< ::DBResult, id_common, A >::config_type_
  query_columns< ::DBResult, id_common, A >::config;

  template <typename A>
  typename query_columns< ::DBResult, id_common, A >::seed_type_
  query_columns< ::DBResult, id_common, A >::seed;

  template <typename A>
  typename query_columns< ::DBResult, id_common, A >::optimal_type_
  query_columns< ::DBResult, id_common, A >::optimal;

  template <typename A>
  typename query_columns< ::DBResult, id_common, A >::feasible_type_
  query_columns< ::DBResult, id_common, A >::feasible;

  template <typename A>
  typename query_columns< ::DBResult, id_common, A >::lower_bound_type_
  query_columns< ::DBResult, id_common, A >::lower_bound;

  template <typename A>
  typename query_columns< ::DBResult, id_common, A >::elapsed_type_
  query_columns< ::DBResult, id_common, A >::elapsed;

  template <typename A>
  typename query_columns< ::DBResult, id_common, A >::time_type_
  query_columns< ::DBResult, id_common, A >::time;

  template <typename A>
  typename query_columns< ::DBResult, id_common, A >::invocation_type_
  query_columns< ::DBResult, id_common, A >::invocation;

  template <typename A>
  typename query_columns< ::DBResult, id_common, A >::cfg_type_
  query_columns< ::DBResult, id_common, A >::cfg;

  template <typename A>
  typename query_columns< ::DBResult, id_common, A >::id_type_
  query_columns< ::DBResult, id_common, A >::id;

#endif // ODB_COMMON_QUERY_COLUMNS_DEF

  // DBResourcesInfo
  //
  template <>
  struct alias_traits<
    ::DBResult,
    id_common,
    access::object_traits_impl< ::DBResourcesInfo, id_common >::res_tag>
  {
  };

  template <>
  struct query_columns_base< ::DBResourcesInfo, id_common >
  {
    // res
    //
    typedef
    odb::alias_traits<
      ::DBResult,
      id_common,
      access::object_traits_impl< ::DBResourcesInfo, id_common >::res_tag>
    res_alias_;
  };

  template <typename A>
  struct query_columns< ::DBResourcesInfo, id_common, A >:
    query_columns_base< ::DBResourcesInfo, id_common >
  {
    // res
    //
    typedef odb::query_column< long unsigned int > res_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::DBResult,
        id_common,
        res_alias_ > >
    res_pointer_type_;

    struct res_type_: res_pointer_type_, res_column_type_
    {
    };

    static res_type_ res;

    // major_pagefaults
    //
    typedef odb::query_column< ::size_t > major_pagefaults_type_;

    static major_pagefaults_type_ major_pagefaults;

    // minor_pagefaults
    //
    typedef odb::query_column< ::size_t > minor_pagefaults_type_;

    static minor_pagefaults_type_ minor_pagefaults;

    // user_usecs
    //
    typedef odb::query_column< long unsigned int > user_usecs_type_;

    static user_usecs_type_ user_usecs;

    // system_usecs
    //
    typedef odb::query_column< long unsigned int > system_usecs_type_;

    static system_usecs_type_ system_usecs;

    // max_rss_size
    //
    typedef odb::query_column< long unsigned int > max_rss_size_type_;

    static max_rss_size_type_ max_rss_size;

    // max_data_size
    //
    typedef odb::query_column< long unsigned int > max_data_size_type_;

    static max_data_size_type_ max_data_size;

    // malloc_max_size
    //
    typedef odb::query_column< long unsigned int > malloc_max_size_type_;

    static malloc_max_size_type_ malloc_max_size;

    // malloc_count
    //
    typedef odb::query_column< long unsigned int > malloc_count_type_;

    static malloc_count_type_ malloc_count;

    // id
    //
    typedef odb::query_column< long unsigned int > id_type_;

    static id_type_ id;
  };

#ifdef ODB_COMMON_QUERY_COLUMNS_DEF

  template <typename A>
  typename query_columns< ::DBResourcesInfo, id_common, A >::res_type_
  query_columns< ::DBResourcesInfo, id_common, A >::res;

  template <typename A>
  typename query_columns< ::DBResourcesInfo, id_common, A >::major_pagefaults_type_
  query_columns< ::DBResourcesInfo, id_common, A >::major_pagefaults;

  template <typename A>
  typename query_columns< ::DBResourcesInfo, id_common, A >::minor_pagefaults_type_
  query_columns< ::DBResourcesInfo, id_common, A >::minor_pagefaults;

  template <typename A>
  typename query_columns< ::DBResourcesInfo, id_common, A >::user_usecs_type_
  query_columns< ::DBResourcesInfo, id_common, A >::user_usecs;

  template <typename A>
  typename query_columns< ::DBResourcesInfo, id_common, A >::system_usecs_type_
  query_columns< ::DBResourcesInfo, id_common, A >::system_usecs;

  template <typename A>
  typename query_columns< ::DBResourcesInfo, id_common, A >::max_rss_size_type_
  query_columns< ::DBResourcesInfo, id_common, A >::max_rss_size;

  template <typename A>
  typename query_columns< ::DBResourcesInfo, id_common, A >::max_data_size_type_
  query_columns< ::DBResourcesInfo, id_common, A >::max_data_size;

  template <typename A>
  typename query_columns< ::DBResourcesInfo, id_common, A >::malloc_max_size_type_
  query_columns< ::DBResourcesInfo, id_common, A >::malloc_max_size;

  template <typename A>
  typename query_columns< ::DBResourcesInfo, id_common, A >::malloc_count_type_
  query_columns< ::DBResourcesInfo, id_common, A >::malloc_count;

  template <typename A>
  typename query_columns< ::DBResourcesInfo, id_common, A >::id_type_
  query_columns< ::DBResourcesInfo, id_common, A >::id;

#endif // ODB_COMMON_QUERY_COLUMNS_DEF

  // DBPapiMeasurement
  //
  template <>
  struct alias_traits<
    ::DBResult,
    id_common,
    access::object_traits_impl< ::DBPapiMeasurement, id_common >::res_tag>
  {
  };

  template <>
  struct query_columns_base< ::DBPapiMeasurement, id_common >
  {
    // res
    //
    typedef
    odb::alias_traits<
      ::DBResult,
      id_common,
      access::object_traits_impl< ::DBPapiMeasurement, id_common >::res_tag>
    res_alias_;
  };

  template <typename A>
  struct query_columns< ::DBPapiMeasurement, id_common, A >:
    query_columns_base< ::DBPapiMeasurement, id_common >
  {
    // res
    //
    typedef odb::query_column< long unsigned int > res_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::DBResult,
        id_common,
        res_alias_ > >
    res_pointer_type_;

    struct res_type_: res_pointer_type_, res_column_type_
    {
    };

    static res_type_ res;

    // event_type
    //
    typedef odb::query_column< ::std::string > event_type_type_;

    static event_type_type_ event_type;

    // event_count
    //
    typedef odb::query_column< long long int > event_count_type_;

    static event_count_type_ event_count;

    // id
    //
    typedef odb::query_column< long unsigned int > id_type_;

    static id_type_ id;
  };

#ifdef ODB_COMMON_QUERY_COLUMNS_DEF

  template <typename A>
  typename query_columns< ::DBPapiMeasurement, id_common, A >::res_type_
  query_columns< ::DBPapiMeasurement, id_common, A >::res;

  template <typename A>
  typename query_columns< ::DBPapiMeasurement, id_common, A >::event_type_type_
  query_columns< ::DBPapiMeasurement, id_common, A >::event_type;

  template <typename A>
  typename query_columns< ::DBPapiMeasurement, id_common, A >::event_count_type_
  query_columns< ::DBPapiMeasurement, id_common, A >::event_count;

  template <typename A>
  typename query_columns< ::DBPapiMeasurement, id_common, A >::id_type_
  query_columns< ::DBPapiMeasurement, id_common, A >::id;

#endif // ODB_COMMON_QUERY_COLUMNS_DEF

  // DBSolution
  //
  template <>
  struct alias_traits<
    ::DBResult,
    id_common,
    access::object_traits_impl< ::DBSolution, id_common >::res_tag>
  {
  };

  template <>
  struct query_columns_base< ::DBSolution, id_common >
  {
    // res
    //
    typedef
    odb::alias_traits<
      ::DBResult,
      id_common,
      access::object_traits_impl< ::DBSolution, id_common >::res_tag>
    res_alias_;
  };

  template <typename A>
  struct query_columns< ::DBSolution, id_common, A >:
    query_columns_base< ::DBSolution, id_common >
  {
    // res
    //
    typedef odb::query_column< long unsigned int > res_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::DBResult,
        id_common,
        res_alias_ > >
    res_pointer_type_;

    struct res_type_: res_pointer_type_, res_column_type_
    {
    };

    static res_type_ res;

    // id
    //
    typedef odb::query_column< long unsigned int > id_type_;

    static id_type_ id;
  };

#ifdef ODB_COMMON_QUERY_COLUMNS_DEF

  template <typename A>
  typename query_columns< ::DBSolution, id_common, A >::res_type_
  query_columns< ::DBSolution, id_common, A >::res;

  template <typename A>
  typename query_columns< ::DBSolution, id_common, A >::id_type_
  query_columns< ::DBSolution, id_common, A >::id;

#endif // ODB_COMMON_QUERY_COLUMNS_DEF

  // DBSolutionJob
  //
  template <>
  struct alias_traits<
    ::DBSolution,
    id_common,
    access::object_traits_impl< ::DBSolutionJob, id_common >::sol_tag>
  {
  };

  template <>
  struct query_columns_base< ::DBSolutionJob, id_common >
  {
    // sol
    //
    typedef
    odb::alias_traits<
      ::DBSolution,
      id_common,
      access::object_traits_impl< ::DBSolutionJob, id_common >::sol_tag>
    sol_alias_;
  };

  template <typename A>
  struct query_columns< ::DBSolutionJob, id_common, A >:
    query_columns_base< ::DBSolutionJob, id_common >
  {
    // sol
    //
    typedef odb::query_column< long unsigned int > sol_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::DBSolution,
        id_common,
        sol_alias_ > >
    sol_pointer_type_;

    struct sol_type_: sol_pointer_type_, sol_column_type_
    {
    };

    static sol_type_ sol;

    // job_id
    //
    typedef odb::query_column< unsigned int > job_id_type_;

    static job_id_type_ job_id;

    // start_time
    //
    typedef odb::query_column< unsigned int > start_time_type_;

    static start_time_type_ start_time;

    // id
    //
    typedef odb::query_column< long unsigned int > id_type_;

    static id_type_ id;
  };

#ifdef ODB_COMMON_QUERY_COLUMNS_DEF

  template <typename A>
  typename query_columns< ::DBSolutionJob, id_common, A >::sol_type_
  query_columns< ::DBSolutionJob, id_common, A >::sol;

  template <typename A>
  typename query_columns< ::DBSolutionJob, id_common, A >::job_id_type_
  query_columns< ::DBSolutionJob, id_common, A >::job_id;

  template <typename A>
  typename query_columns< ::DBSolutionJob, id_common, A >::start_time_type_
  query_columns< ::DBSolutionJob, id_common, A >::start_time;

  template <typename A>
  typename query_columns< ::DBSolutionJob, id_common, A >::id_type_
  query_columns< ::DBSolutionJob, id_common, A >::id;

#endif // ODB_COMMON_QUERY_COLUMNS_DEF

  // DBIntermediate
  //
  template <>
  struct alias_traits<
    ::DBResult,
    id_common,
    access::object_traits_impl< ::DBIntermediate, id_common >::res_tag>
  {
  };

  template <>
  struct alias_traits<
    ::DBSolution,
    id_common,
    access::object_traits_impl< ::DBIntermediate, id_common >::solution_tag>
  {
  };

  template <>
  struct query_columns_base< ::DBIntermediate, id_common >
  {
    // res
    //
    typedef
    odb::alias_traits<
      ::DBResult,
      id_common,
      access::object_traits_impl< ::DBIntermediate, id_common >::res_tag>
    res_alias_;

    // solution
    //
    typedef
    odb::alias_traits<
      ::DBSolution,
      id_common,
      access::object_traits_impl< ::DBIntermediate, id_common >::solution_tag>
    solution_alias_;
  };

  template <typename A>
  struct query_columns< ::DBIntermediate, id_common, A >:
    query_columns_base< ::DBIntermediate, id_common >
  {
    // res
    //
    typedef odb::query_column< long unsigned int > res_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::DBResult,
        id_common,
        res_alias_ > >
    res_pointer_type_;

    struct res_type_: res_pointer_type_, res_column_type_
    {
    };

    static res_type_ res;

    // time
    //
    typedef odb::query_column< double > time_type_;

    static time_type_ time;

    // iteration
    //
    typedef odb::query_column< unsigned int > iteration_type_;

    static iteration_type_ iteration;

    // costs
    //
    typedef odb::query_column< double > costs_type_;

    static costs_type_ costs;

    // bound
    //
    typedef odb::query_column< double > bound_type_;

    static bound_type_ bound;

    // solution
    //
    typedef odb::query_column< long unsigned int > solution_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::DBSolution,
        id_common,
        solution_alias_ > >
    solution_pointer_type_;

    struct solution_type_: solution_pointer_type_, solution_column_type_
    {
    };

    static solution_type_ solution;

    // id
    //
    typedef odb::query_column< long unsigned int > id_type_;

    static id_type_ id;
  };

#ifdef ODB_COMMON_QUERY_COLUMNS_DEF

  template <typename A>
  typename query_columns< ::DBIntermediate, id_common, A >::res_type_
  query_columns< ::DBIntermediate, id_common, A >::res;

  template <typename A>
  typename query_columns< ::DBIntermediate, id_common, A >::time_type_
  query_columns< ::DBIntermediate, id_common, A >::time;

  template <typename A>
  typename query_columns< ::DBIntermediate, id_common, A >::iteration_type_
  query_columns< ::DBIntermediate, id_common, A >::iteration;

  template <typename A>
  typename query_columns< ::DBIntermediate, id_common, A >::costs_type_
  query_columns< ::DBIntermediate, id_common, A >::costs;

  template <typename A>
  typename query_columns< ::DBIntermediate, id_common, A >::bound_type_
  query_columns< ::DBIntermediate, id_common, A >::bound;

  template <typename A>
  typename query_columns< ::DBIntermediate, id_common, A >::solution_type_
  query_columns< ::DBIntermediate, id_common, A >::solution;

  template <typename A>
  typename query_columns< ::DBIntermediate, id_common, A >::id_type_
  query_columns< ::DBIntermediate, id_common, A >::id;

#endif // ODB_COMMON_QUERY_COLUMNS_DEF

  // DBError
  //
  // DBExtendedMeasure
  //
  template <>
  struct alias_traits<
    ::DBResult,
    id_common,
    access::object_traits_impl< ::DBExtendedMeasure, id_common >::res_tag>
  {
  };

  template <>
  struct query_columns_base< ::DBExtendedMeasure, id_common >
  {
    // res
    //
    typedef
    odb::alias_traits<
      ::DBResult,
      id_common,
      access::object_traits_impl< ::DBExtendedMeasure, id_common >::res_tag>
    res_alias_;
  };

  template <typename A>
  struct query_columns< ::DBExtendedMeasure, id_common, A >:
    query_columns_base< ::DBExtendedMeasure, id_common >
  {
    // res
    //
    typedef odb::query_column< long unsigned int > res_column_type_;

    typedef
    odb::query_pointer<
      odb::pointer_query_columns<
        ::DBResult,
        id_common,
        res_alias_ > >
    res_pointer_type_;

    struct res_type_: res_pointer_type_, res_column_type_
    {
    };

    static res_type_ res;

    // key
    //
    typedef odb::query_column< ::std::string > key_type_;

    static key_type_ key;

    // iteration
    //
    typedef odb::query_column< unsigned int > iteration_type_;

    static iteration_type_ iteration;

    // time
    //
    typedef odb::query_column< double > time_type_;

    static time_type_ time;

    // v_int
    //
    typedef odb::query_column< int > v_int_type_;

    static v_int_type_ v_int;

    // v_double
    //
    typedef odb::query_column< double > v_double_type_;

    static v_double_type_ v_double;

    // id
    //
    typedef odb::query_column< long unsigned int > id_type_;

    static id_type_ id;
  };

#ifdef ODB_COMMON_QUERY_COLUMNS_DEF

  template <typename A>
  typename query_columns< ::DBExtendedMeasure, id_common, A >::res_type_
  query_columns< ::DBExtendedMeasure, id_common, A >::res;

  template <typename A>
  typename query_columns< ::DBExtendedMeasure, id_common, A >::key_type_
  query_columns< ::DBExtendedMeasure, id_common, A >::key;

  template <typename A>
  typename query_columns< ::DBExtendedMeasure, id_common, A >::iteration_type_
  query_columns< ::DBExtendedMeasure, id_common, A >::iteration;

  template <typename A>
  typename query_columns< ::DBExtendedMeasure, id_common, A >::time_type_
  query_columns< ::DBExtendedMeasure, id_common, A >::time;

  template <typename A>
  typename query_columns< ::DBExtendedMeasure, id_common, A >::v_int_type_
  query_columns< ::DBExtendedMeasure, id_common, A >::v_int;

  template <typename A>
  typename query_columns< ::DBExtendedMeasure, id_common, A >::v_double_type_
  query_columns< ::DBExtendedMeasure, id_common, A >::v_double;

  template <typename A>
  typename query_columns< ::DBExtendedMeasure, id_common, A >::id_type_
  query_columns< ::DBExtendedMeasure, id_common, A >::id;

#endif // ODB_COMMON_QUERY_COLUMNS_DEF
}

#include "db_objects-odb.ixx"

#include <odb/post.hxx>

#endif // DB_OBJECTS_ODB_HXX
